---
export interface Props {}
---

<div id="background-vfx">
  <div id="magnet1"></div>
  <div id="magnet2"></div>
  <canvas id="hero-canvas"> </canvas>
</div>

<script>
  import rough from "roughjs";
  import { vec, vector } from "../../public/animation-resources/vetores";
  import createParticle from "../../public/animation-resources/particle";
  import magneticDipole from "../../public/animation-resources/magneticDipole";
  import type { Tparticle } from "../../public/animation-resources/types";
  import {
    easeWalkTruArray,
    trace,
    traceGrid,
    TtraceGrid,
  } from "../../public/animation-resources/tracers";
  import { createGrid } from "../../public/animation-resources/gridCells";

  /*----------------------------------------------------------
  --------------------0-GET DOM ELEMENTS----------------------
  ----------------------------------------------------------*/
  const textContent = document.querySelector("#background-vfx") as HTMLElement;
  const heroCanvas = document.querySelector("#hero-canvas") as HTMLElement;
  const magnet1 = document.querySelector("#magnet1") as HTMLDivElement;
  const magnet2 = document.querySelector("#magnet2") as HTMLDivElement;
  const herocanvas = document.getElementById(
    "hero-canvas"
  ) as HTMLCanvasElement;

  /*----------------------------------------------------------
  --------------------1-GLOBAL VARIABLES----------------------
  ----------------------------------------------------------*/
  const magnets = [magnet1, magnet2];
  let isDragging = -1;
  const textColor = getComputedStyle(textContent).color;
  const heroColor = getComputedStyle(heroCanvas).color;
  const magnetColor = getComputedStyle(magnets[0]).color;
  const sentence = " #web #código #educação #arte #design";
  var ctx = herocanvas.getContext("2d") as CanvasRenderingContext2D;
  let gridFontSize;
  const num = 2;
  let particles = [] as Tparticle[];
  let magnetsSize = {} as { x: number; y: number };
  let w = window.innerWidth;
  let h = window.innerHeight;
  const safeRadius = 2;
  let rc = rough.canvas(herocanvas);
  const pixels = [] as string[];
  let gridTracers: TtraceGrid;

  let mouse = { x: 0, y: 0 };
  let start = { x: 0, y: 0 };

  let mouseMove = function (e: MouseEvent) {
    mouse.x = e.x;
    mouse.y = e.y;

    if (isDragging != -1) {
      particles[isDragging].position.x = e.x;
      particles[isDragging].position.y = e.y;
    }
  };

  let mouseDown = function (e: MouseEvent, id: number) {
    e.preventDefault;
    isDragging = id;
    start.x = e.x;
    start.y = e.y;
  };

  let mouseUp = function (e: MouseEvent | TouchEvent, id: number) {
    e.preventDefault();
    isDragging = -1;
  };

  window.onmousemove = mouseMove;
  magnets[0].onmousedown = (e) => mouseDown(e, 0);
  magnets[1].onmousedown = (e) => mouseDown(e, 1);
  magnets[0].onmouseup = (e) => mouseUp(e, 0);
  magnets[1].onmouseup = (e) => mouseUp(e, 1);

  let touchMove = function (e: TouchEvent, id: number) {
    mouse.x = e.changedTouches[0].clientX;
    mouse.y = e.changedTouches[0].clientY;

    if (isDragging != -1) {
      particles[isDragging].position.x = e.changedTouches[0].clientX;
      particles[isDragging].position.y = e.changedTouches[0].clientY;
    }
  };

  let touchStart = function (e: TouchEvent, id: number) {
    e.preventDefault;
    isDragging = id;
    start.x = e.changedTouches[0].clientX;
    start.y = e.changedTouches[0].clientY;
  };

  window.ontouchmove = (e) => touchMove(e, 0);
  magnets[0].ontouchstart = (e) => touchStart(e, 0);
  magnets[1].ontouchstart = (e) => touchStart(e, 1);
  magnets[0].ontouchend = (e) => mouseUp(e, 0);
  magnets[1].ontouchend = (e) => mouseUp(e, 1);
  magnets[0].ontouchcancel = (e) => mouseUp(e, 0);
  magnets[1].ontouchcancel = (e) => mouseUp(e, 1);

  /*----------------------------------------------------------
  --------------------2-SETUP ON RESIZE----------------------
  ----------------------------------------------------------*/
  function setupCanvas() {
    w = window.innerWidth;
    h = window.innerHeight;
    herocanvas.width = w;
    herocanvas.height = h;
    gridFontSize = parseInt(getComputedStyle(textContent).fontSize, 10);
    magnetsSize = {
      x: gridFontSize * 3,
      y: gridFontSize * 5,
    };

    //1.Initialize magnets
    particles = [];
    for (let n = 0; n < num; n++) {
      let randomPosition = vec(
        0.2 * w + 0.6 * Math.random() * w,
        0.2 * h + 0.6 * Math.random() * h,
        0
      );

      let newParticle = createParticle({
        index: n,
        position: randomPosition,
        direction: vec().random2D(1),

        behaviours: [magneticDipole],
      });
      particles.push(newParticle);
    }

    //2. Initialize grid
    let grid = createGrid(
      [herocanvas.width, herocanvas.height],
      [gridFontSize, gridFontSize]
    );
    let numTracers = 6;
    let tracersLen = 10;
    let tracerLife = 5;
    let tracerLifeVariation = 0.1;
    //2.b Initalize tracers
    gridTracers = traceGrid(
      numTracers,
      tracersLen,
      tracerLife,
      tracerLifeVariation,
      grid,
      ctx,
      particles,
      "magnet"
    );
    //3. Fill the background string

    for (let n = 0; n < grid.cells.length; n++) {
      pixels.push(`${sentence.charAt(n % sentence.length)}`);
    }
  }

  /*----------------------------------------------------------
  --------------------3-FUNCTIONS FOR LOOP--------------------
  ----------------------------------------------------------*/
  let update = () => {
    for (let i = 0; i < num; i++) {
      let thisParticle = particles[i];
      let tooClose = particles.filter(
        (particle) =>
          vec()
            .copy(particle.position)
            .distanceToSquared(thisParticle.position) < safeRadius
      );
      let agents = particles.filter((x: any) => !tooClose.includes(x));
      particles[i].applyForces(agents);
    }
  };

  let move = () => {
    for (let i = 0; i < num; i++) {
      particles[i].move();
    }
    magnets.forEach((magnet, index) => {
      magnet.style.width = `${magnetsSize.y}px`;
      magnet.style.height = `${magnetsSize.x}px`;
      magnet.style.top = `${particles[index].position.y}px`;
      magnet.style.left = `${particles[index].position.x}px`;
      magnet.style.transformOrigin = "top left";
      magnet.style.rotate = `${particles[index].direction.heading()}rad`;
    });
  };

  let show = () => {
    particles.forEach((particle) => {
      particle.show(rc, magnetsSize, magnetColor);
    });
  };

  /*----------------------------------------------------------
  ---------------------4-DRAW LOOP----------------------------
  ----------------------------------------------------------*/
  let t = 0;
  let tracesOnDrag = [] as vector[][];

  function animate() {
    requestAnimationFrame(animate);

    if (
      herocanvas.width != window.innerWidth ||
      herocanvas.height != window.innerHeight
    ) {
      setupCanvas();
    }

    ctx.clearRect(0, 0, herocanvas.width, herocanvas.height);
    update();
    move();
    //grid.show(rc); //test & fun
    if (t % 11 == 0) {
      gridTracers.update();
      t = 0;
    }
    gridTracers.showText(pixels, textColor, heroColor);
    show();

    //Hover effect
    if (isDragging != -1) {
      if (tracesOnDrag.length < 1) {
        let vc = vec()
          .random2D(magnetsSize.y)
          .add(particles[isDragging].position);
        //rc.circle(vc.x, vc.y, 100, { fill: "blue" }); //test
        let traceArr = trace(
          particles[isDragging].physics.magnet.field,
          vc,
          (a, b) => vec().copy(a).add(b.setMag(5)),
          100,
          particles[isDragging]
        );
        tracesOnDrag.push(traceArr);
      } else {
        tracesOnDrag.forEach((traceArr) => {
          let pieceToShow = easeWalkTruArray(t, 10, 0.5, traceArr);
          console.log(pieceToShow[0].x, pieceToShow[0].y);
          rc.linearPath(
            pieceToShow.map((vec) => [vec.x, vec.y]),
            { stroke: "white", strokeWidth: 2 }
          );
        });
      }
    } else {
      tracesOnDrag = [] as vector[][];
    }

    t++;
  }
  animate();
</script>

<style>
  #background-vfx {
    position: absolute;
    top: 0;
    left: 0;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
    width: 100%;
    height: 100%;
    font-size: max(2.2vw, 3vh);
    color: var(--pallete4c);
  }

  #hero-canvas {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    background-color: var(--pallete4a);
    color: var(--pallete4cA);
  }

  #magnet1,
  #magnet2 {
    position: absolute;
    top: 0;
    left: 0;
    border: 1px solid var(--pallete4b);
    transform: translate(-50%, -50%);
    color: var(--pallete4b);
  }

  #magnet1:hover,
  #magnet2:hover {
    position: relative;
    display: inline-block;
    content: " ";
    width: 100%;
    height: 100%;
    border: 2px solid var(--pallete4d);
    box-shadow: 1px 1px 5px var(--pallete4d);
  }

  /* #magnet1::before,
  #magnet2::before {
    position: relative;
    display: inline-block;
    content: " ";
    width: 100%;
    height: 100%;
    outline: 1px solid var(--pallete4a);
    outline-offset: -1px;
  } */
</style>
