---
export interface Props {}
---

<div id="background-vfx">
  <div id="magnet1"></div>
  <div id="magnet2"></div>
  <canvas id="hero-canvas"> </canvas>
</div>

<script>
  import rough from "roughjs";
  import { vec, vector } from "../../public/animation-resources/vetores";
  import createParticle from "../../public/animation-resources/particle";
  import magneticDipole from "../../public/animation-resources/magneticDipole";
  import type { Tparticle } from "../../public/animation-resources/types";
  import {
    easeWalkTruArray,
    traceGrid,
    traceVectorField,
    TtraceGrid,
  } from "../../public/animation-resources/tracers";
  import {
    createGrid,
    Tgrid,
  } from "../../public/animation-resources/gridCells";

  /*----------------------------------------------------------
  --------------------0-GET DOM ELEMENTS----------------------
  ----------------------------------------------------------*/
  const textContent = document.querySelector("#background-vfx") as HTMLElement;
  const heroCanvas = document.querySelector("#hero-canvas") as HTMLElement;
  const magnet1 = document.querySelector("#magnet1") as HTMLDivElement;
  const magnet2 = document.querySelector("#magnet2") as HTMLDivElement;
  const herocanvas = document.getElementById(
    "hero-canvas"
  ) as HTMLCanvasElement;

  /*----------------------------------------------------------
  --------------------1-GLOBAL VARIABLES----------------------
  ----------------------------------------------------------*/
  const magnets = [magnet1, magnet2];
  let isDragging = -1;
  const traceDraggingNumber = 10;
  const traceDragDuration = 15;
  const traceDragLen = 50;
  const textColor = getComputedStyle(textContent).color;
  const heroColor = getComputedStyle(heroCanvas).color;
  const magnetColor = getComputedStyle(magnets[0]).color;
  const sentence = "#web#código#educação#arte#design";
  var ctx = herocanvas.getContext("2d") as CanvasRenderingContext2D;
  let gridFontSize;
  const num = 2;
  let particles = [] as Tparticle[];
  let magnetsSize = {} as { x: number; y: number };
  let w = window.innerWidth;
  let h = window.innerHeight;
  const safeRadius = 5;
  let rc = rough.canvas(herocanvas);
  let gridTracers: TtraceGrid;

  let mouse = { x: 0, y: 0 };
  let start = { x: 0, y: 0 };

  let mouseMove = function (e: MouseEvent) {
    mouse.x = e.x;
    mouse.y = e.y;

    if (isDragging != -1) {
      particles[isDragging].position.x = e.x;
      particles[isDragging].position.y = e.y;
    }
  };

  let mouseDown = function (e: MouseEvent, id: number) {
    e.preventDefault;
    isDragging = id;
    start.x = e.x;
    start.y = e.y;
  };

  let mouseUp = function (e: MouseEvent | TouchEvent, id: number) {
    e.preventDefault();
    isDragging = -1;
  };

  window.onmousemove = mouseMove;
  magnets[0].onmousedown = (e) => mouseDown(e, 0);
  magnets[1].onmousedown = (e) => mouseDown(e, 1);
  magnets[0].onmouseup = (e) => mouseUp(e, 0);
  magnets[1].onmouseup = (e) => mouseUp(e, 1);

  let touchMove = function (e: TouchEvent, id: number) {
    mouse.x = e.changedTouches[0].clientX;
    mouse.y = e.changedTouches[0].clientY;

    if (isDragging != -1) {
      particles[isDragging].position.x = e.changedTouches[0].clientX;
      particles[isDragging].position.y = e.changedTouches[0].clientY;
    }
  };

  let touchStart = function (e: TouchEvent, id: number) {
    e.preventDefault;
    isDragging = id;
    start.x = e.changedTouches[0].clientX;
    start.y = e.changedTouches[0].clientY;
  };

  window.ontouchmove = (e) => touchMove(e, 0);
  magnets[0].ontouchstart = (e) => touchStart(e, 0);
  magnets[1].ontouchstart = (e) => touchStart(e, 1);
  magnets[0].ontouchend = (e) => mouseUp(e, 0);
  magnets[1].ontouchend = (e) => mouseUp(e, 1);
  magnets[0].ontouchcancel = (e) => mouseUp(e, 0);
  magnets[1].ontouchcancel = (e) => mouseUp(e, 1);

  /*----------------------------------------------------------
  --------------------2-SETUP ON RESIZE----------------------
  ----------------------------------------------------------*/
  function setupCanvas() {
    w = window.innerWidth;
    h = window.innerHeight;
    herocanvas.width = w;
    herocanvas.height = h;
    gridFontSize = parseInt(getComputedStyle(textContent).fontSize, 10);
    magnetsSize = {
      x: gridFontSize * 3,
      y: gridFontSize * 5,
    };

    //1.Initialize magnets
    particles = [];
    for (let n = 0; n < num; n++) {
      let randomPosition = vec(
        0.2 * w + 0.6 * Math.random() * w,
        0.2 * h + 0.6 * Math.random() * h,
        0
      );

      let newParticle = createParticle({
        index: n,
        position: randomPosition,
        direction: vec().random2D(1),

        behaviours: [magneticDipole],
      });
      particles.push(newParticle);
    }

    //2. Initialize grid
    let grid = createGrid(
      [herocanvas.width, herocanvas.height],
      [gridFontSize, gridFontSize]
    );
    let numTracers = 6;
    let tracersLen = 10;
    let tracerLife = 5;
    let tracerLifeVariation = 0.1;
    //2.b Initalize tracers
    gridTracers = traceGrid(
      numTracers,
      tracersLen,
      tracerLife,
      tracerLifeVariation,
      grid,
      ctx,
      particles,
      "magnet"
    );
    //3. Fill the background string
  }

  /*----------------------------------------------------------
  --------------------3-FUNCTIONS FOR LOOP--------------------
  ----------------------------------------------------------*/
  // let showRandomWords = function (bsentence: string, bpixels: string[]) {
  //   let words = bsentence.split("#");
  //   words.shift();
  //   let howManySentences = Math.floor(bpixels.length / bsentence.length);
  //   let randomSentenceIndex = Math.floor(Math.random() * howManySentences);
  //   let randomWord = Math.floor(Math.random() * words.length);
  //   let randomWordIndex = 0;
  //   for (let n = 0; n < randomWord; n++) {
  //     randomWordIndex += words[randomWord].length + 1;
  //   }
  //   let randomIndex = randomSentenceIndex + randomWordIndex;
  //   ctx.fillStyle = textColor;
  //   //ctx.fillText(char, cell.pos[0], cell.pos[1]);
  // };

  let update = () => {
    for (let i = 0; i < num; i++) {
      let thisParticle = particles[i];
      let tooClose = particles.filter(
        (particle) =>
          vec()
            .copy(particle.position)
            .distanceToSquared(thisParticle.position) < safeRadius
      );
      let agents = particles.filter((x: any) => !tooClose.includes(x));
      particles[i].applyForces(agents);
    }
  };

  let move = () => {
    for (let i = 0; i < num; i++) {
      particles[i].move();
    }
    magnets.forEach((magnet, index) => {
      magnet.style.width = `${magnetsSize.y}px`;
      magnet.style.height = `${magnetsSize.x}px`;
      magnet.style.top = `${particles[index].position.y}px`;
      magnet.style.left = `${particles[index].position.x}px`;
      magnet.style.transformOrigin = "top left";
      magnet.style.rotate = `${particles[index].direction.heading()}rad`;
    });
  };

  let show = () => {
    particles.forEach((particle) => {
      particle.show(rc, magnetsSize, heroColor);
    });
  };

  /*----------------------------------------------------------
  ---------------------4-DRAW LOOP----------------------------
  ----------------------------------------------------------*/
  let t = 0;
  let tracesOnDrag = [] as vector[][];
  let tracesOnDragInternalTime = Array(traceDraggingNumber).fill(0, 0);

  function animate() {
    if (t > 1024) t = 0;
    requestAnimationFrame(animate);

    if (
      herocanvas.width != window.innerWidth ||
      herocanvas.height != window.innerHeight
    ) {
      setupCanvas();
    }

    ctx.clearRect(0, 0, herocanvas.width, herocanvas.height);
    update();
    move();
    //grid.show(rc); //test & fun
    if (t % 11 == 0) {
      gridTracers.update();
    }
    gridTracers.showText(sentence, textColor, heroColor, textColor, t);

    if (isDragging != -1) {
      if (tracesOnDrag.length < 1) {
        for (let n = 0; n < traceDraggingNumber; n++) {
          let vc = vec()
            .random2D(magnetsSize.y)
            .add(particles[isDragging].position);
          let traceArr = traceVectorField(
            particles.map((particle) => particle.physics.magnet.field),
            vc,
            (a, b) => vec().copy(a).add(b.setMag(5)),
            traceDragLen,
            particles[isDragging]
          );
          tracesOnDrag.push(traceArr);
        }
      } else {
        tracesOnDrag.forEach((traceArr, index) => {
          if (tracesOnDragInternalTime[index] > traceDragDuration) {
            tracesOnDrag[index] = [];

            let vc = vec()
              .random2D(magnetsSize.y)
              .add(particles[isDragging].position);
            tracesOnDrag[index] = traceVectorField(
              particles.map((particle) => particle.physics.magnet.field),
              vc,
              (a, b) => vec().copy(a).add(b.setMag(5)),
              traceDragLen,
              particles[isDragging]
            );
            tracesOnDragInternalTime[index] = 0;
          }

          let pieceToShow = easeWalkTruArray(
            tracesOnDragInternalTime[index],
            traceDragDuration,
            0.3,
            traceArr
          );
          //console.log(pieceToShow); //test
          rc.curve(
            pieceToShow.map((vec) => [vec.x, vec.y]),
            { stroke: textColor, strokeWidth: 1 }
          );

          tracesOnDragInternalTime[index]++;
        });
      }
    } else {
      tracesOnDrag = [] as vector[][];
    }
    show();
    t++;
  }
  animate();
</script>

<style>
  #background-vfx {
    position: absolute;
    top: 0;
    left: 0;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    overflow: hidden;
    width: 100%;
    height: 100%;
    font-size: max(2.2vw, 3vh);
    color: var(--pallete4c);
  }

  #hero-canvas {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    background-color: var(--pallete4a);
    color: var(--pallete4cA);
  }

  #magnet1,
  #magnet2 {
    position: absolute;
    top: 0;
    left: 0;
    border: 1px solid var(--pallete4b);
    transform: translate(-50%, -50%);
    color: var(--pallete4b);
    z-index: 2;
  }

  #magnet1::before,
  #magnet2::before {
    position: relative;
    display: inline-block;
    content: " ";
    width: 100%;
    height: 100%;
    outline: 1px solid var(--pallete4a);
    outline-offset: -1px;
  }
</style>
